#+SETUPFILE: setup.org

* Contents                                                         :toc_4_gh:
 - [[#lighting-calculations][Lighting calculations]]
     - [[#lambert][Lambert]]
         - [[#two-sided-lambert-using-absolute-dot-product][Two-sided lambert (using absolute dot product)]]
     - [[#phong][Phong]]
     - [[#blinn-phong][Blinn-Phong]]
     - [[#beckmann-distribution][Beckmann distribution]]
     - [[#beckmann-specular][Beckmann specular]]
     - [[#schlick-approximation][Schlick approximation]]
         - [[#calculate-r0-from-refractive-indices][Calculate R0 from refractive indices]]
     - [[#gaussian-specular][Gaussian specular]]
     - [[#cook-torrance][Cook-Torrance]]
     - [[#oren-nayar][Oren-Nayar]]
     - [[#ward][Ward]]
     - [[#skylight][Skylight]]
     - [[#spotlight][Spotlight]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Lighting calculations
** Lambert

#+BEGIN_SRC glsl :noweb-ref lambert
  float lambert(vec3 surfaceNormal, vec3 lightDirection) {
    return clamp(dot(surfaceNormal, lightDirection), 0.0, 1.0);
  }
#+END_SRC

*** Two-sided lambert (using absolute dot product)

#+BEGIN_SRC glsl :noweb-ref lambert-abs
  float lambertAbs(vec3 surfaceNormal, vec3 lightDirection) {
    return clamp(abs(dot(surfaceNormal, lightDirection)), 0.0, 1.0);
  }
#+END_SRC

** Phong

#+BEGIN_SRC glsl :noweb-ref phong
  float phong(vec3 lightDir, vec3 eyeDir, vec3 surfaceNormal) {
    return dot(reflect(-lightDir, surfaceNormal), eyeDir);
  }
#+END_SRC

** Blinn-Phong

#+BEGIN_SRC glsl :noweb-ref blinn-phong
  float blinnPhong(vec3 lightDir, vec3 eyeDir, vec3 surfaceNormal) {
    return dot(normalize(lightDir + eyeDir), surfaceNormal);
  }
#+END_SRC

** Beckmann distribution

#+BEGIN_SRC glsl :noweb-ref beckmann-dist
  float beckmannDistribution(float x, float roughness) {
    float NdotH = max(x, 1e-4);
    float cos2Alpha = NdotH * NdotH;
    float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;
    float roughness2 = roughness * roughness;
    float denom = PI * roughness2 * cos2Alpha * cos2Alpha;
    return exp(tan2Alpha / roughness2) / denom;
  }
#+END_SRC

** Beckmann specular

#+BEGIN_SRC glsl :noweb-ref beckmann-specular
  float beckmannSpecular(vec3 lightDirection,
                         vec3 viewDirection,
                         vec3 surfaceNormal,
                         float roughness) {
    return beckmannDistribution(dot(surfaceNormal, normalize(lightDirection + viewDirection)), roughness);
  }
#+END_SRC

** Schlick approximation

- https://en.wikipedia.org/wiki/Schlick%27s_approximation

#+BEGIN_SRC glsl :noweb-ref schlick
  float schlick(float r0, float smooth, vec3 normal, vec3 view) {
    float d = clamp(1.0 - dot(normal, -view), 0.0, 1.0);
    float d2 = d * d;
    return mix(r0, 1.0, smooth * d2 * d2 * d);
  }
#+END_SRC

*** Calculate R0 from refractive indices

#+BEGIN_SRC glsl :noweb-ref schlick-r0
  float schlickR0(float ior1, float ior2) {
    float r = (ior1 - ior2) / (ior1 + ior2);
    return r * r;
  }
#+END_SRC

** Gaussian specular

#+BEGIN_SRC glsl :noweb-ref gaussian
  float gaussianSpecular(vec3 lightDirection,
                         vec3 viewDirection,
                         vec3 surfaceNormal,
                         float shininess) {
    vec3 H = normalize(lightDirection + viewDirection);
    float theta = acos(dot(H, surfaceNormal));
    float w = theta / shininess;
    return exp(-w * w);
  }
#+END_SRC

** Cook-Torrance

#+BEGIN_SRC glsl :noweb-ref cook-torrance
  float cookTorrance(vec3 lightDirection,
                     vec3 viewDirection,
                     vec3 surfaceNormal,
                     float roughness,
                     float fresnel) {

    float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);
    float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);

    //Half angle vector
    vec3 H = normalize(lightDirection + viewDirection);

    //Geometric term
    float NdotH = max(dot(surfaceNormal, H), 0.0);
    float VdotH = max(dot(viewDirection, H), 1e-6);
    float LdotH = max(dot(lightDirection, H), 1e-6);
    float G1 = (2.0 * NdotH * VdotN) / VdotH;
    float G2 = (2.0 * NdotH * LdotN) / LdotH;
    float G = min(1.0, min(G1, G2));

    //Distribution term
    float D = beckmannDistribution(NdotH, roughness);

    //Fresnel term
    float F = pow(1.0 - VdotN, fresnel);

    //Multiply terms and done
    return G * F * D / max(PI * VdotN, 1e-6);
  }
#+END_SRC

** Oren-Nayar

#+BEGIN_SRC glsl :noweb-ref oren-nayar
  float orenNayar(vec3 lightDirection,
                  vec3 viewDirection,
                  vec3 surfaceNormal,
                  float roughness,
                  float albedo) {

    float LdotV = dot(lightDirection, viewDirection);
    float NdotL = dot(lightDirection, surfaceNormal);
    float NdotV = dot(surfaceNormal, viewDirection);

    float s = LdotV - NdotL * NdotV;
    float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));

    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);

    return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;
  }
#+END_SRC

** Ward

#+BEGIN_SRC glsl :noweb-ref ward
  float ward(vec3 lightDirection,
             vec3 viewDirection,
             vec3 surfaceNormal,
             vec3 fiberParallel,
             vec3 fiberPerpendicular,
             float shinyParallel,
             float shinyPerpendicular) {

    float NdotL = dot(surfaceNormal, lightDirection);
    float NdotR = dot(surfaceNormal, viewDirection);

    if(NdotL < 0.0 || NdotR < 0.0) {
      return 0.0;
    }

    vec3 H = normalize(lightDirection + viewDirection);

    float NdotH = dot(surfaceNormal, H);
    float XdotH = dot(fiberParallel, H);
    float YdotH = dot(fiberPerpendicular, H);

    float coeff = sqrt(NdotL/NdotR) / (2.0 * TWO_PI * shinyParallel * shinyPerpendicular);
    float theta = (pow(XdotH/shinyParallel, 2.0) + pow(YdotH/shinyPerpendicular, 2.0)) / (1.0 + NdotH);

    return coeff * exp(-2.0 * theta);
  }
#+END_SRC

** Skylight

#+BEGIN_SRC glsl :noweb-ref skylight
  float skylight(float height){
    return smoothstep(0.0, PI, PI - acos(height));
  }
#+END_SRC

#+BEGIN_SRC glsl :noweb-ref skylight-color
  vec3 skylightColor(vec3 col1, vec3 col2, float height) {
    return mix(col1, col2, skylight(height));
  }
#+END_SRC

** Spotlight

#+BEGIN_SRC glsl :noweb-ref spotlight-att
  float spotlightAttenuation(vec3 dir, float amp){
    float dist = length(dir);
    float radiance = 1.0 / (1.0 + pow(dist / amp, 2.0));
    return clamp(radiance * amp, 0.0, 1.0);
  }
#+END_SRC

#+BEGIN_SRC glsl :noweb-ref spotlight-influence
  float spotlightInfluence(vec3 normal, float coneAngle, float fallOffAngle){
    float minConeAngle = (360.0 - coneAngle - fallOffAngle) * RAD;
    float maxConeAngle = (360.0 - coneAngle) * RAD;
    return smoothstep(minConeAngle, maxConeAngle, acos(normal.z));
  }
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :noweb yes :tangle ../babel/src/thi/ng/glsl/lighting.cljs :mkdirp yes :padline no
  (ns thi.ng.glsl.lighting
    (:require-macros
     [thi.ng.glsl.core :refer [defglsl]]))

  (defglsl lambert
    nil "
  <<lambert>>")

  (defglsl lambert-abs
    nil "
  <<lambert-abs>>")

  (defglsl phong
    nil "
  <<phong>>")

  (defglsl blinn-phong
    nil "
  <<blinn-phong>>")

  (defglsl schlick
    nil "
  <<schlick>>")

  (defglsl schlick-r0
    nil "
  <<schlick-r0>>")

  (defglsl beckmann-distribution
    nil "
  <<beckmann-dist>>")

  (defglsl beckmann-specular
    [beckmann-distribution] "
  <<beckmann-specular>>")

  (defglsl gaussian-specular
    nil "
  <<gaussian>>")

  (defglsl cook-torrance
    [beckmann-distribution] "
  <<cook-torrance>>")

  (defglsl oren-nayar
    nil "
  <<oren-nayar>>")

  (defglsl ward
    nil "
  <<ward>>")

  (defglsl skylight
    nil "
  <<skylight>>")

  (defglsl skylight-color
    [skylight] "
  <<skylight-color>>")

  (defglsl spotlight-attenuation
    nil "
  <<spotlight-att>>")

  (defglsl spotlight-influence
    nil "
  <<spotlight-influence>>")
#+END_SRC
